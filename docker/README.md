# Docker

*Образ (Image)* - чертёж для контейнеров, содержит код приложения и окружение. На основе образа создаются контейнеры. 

*Контейнеры* - пакеты, экземпляры образа. Контейнер - единица программного обеспечения, которую мы можем запустить. На основе одного образа создаётся n-ное количество контейнеров.


Где найти образ?
* Взять готовый на [Docker Hub](https://hub.docker.com/).
* Создать свой на основе готового из хаба.

```sh
# Скачать образ "Python"
docker pull python

# Запустить контейнер на базе образа "Python". Если он не скачен, докер его скачает из хаба.
docker run python

# Запустить контейнер и открыть интерактивную консоль
docker run -it python

# Показать запущенные контейнеры
docker ps

# Показать все контейнеры
docker ps -a

# Остановить контейнер
docker stop имя_контейнера
```
Для создания кастомного образа, в корне проекта создаём `Dockerfile`. В нём пишутся инструкции, которые выполнит докер при билде образа и при запуске контейнера.

Для поддержки докерфайла в VS Code есть [расширение от Майкрософт](https://marketplace.visualstudio.com/items?itemName=ms-azuretools.vscode-docker).

## Dockerfile

1. Первая инструкция - на основе какого образа создаём свой:
```docker
FROM python
```

2. Какие файлы из папки проекта нужны и куда их поместить в образе. Пути работают с юниксовыми абсолютными и относительными путями.
```docker
COPY папка_на_хосте папка_в_образе

# Копируем все файлы проекта в корень образа
COPY . .

# Копируем все файлы проекта в папку app (папка будет создана)
COPY . /app
```

3. Меняем рабочую папку. Команды будут выполнятся из-под неё. После этого `COPY . /app` можно поменять на `COPY . .`
```docker
WORKDIR /app
```

4. Запускаем нужные команды:
```docker
RUN pip install -r requirements.txt
```

5. Запускаем приложение. Если запустим через `RUN`, то приложение запустится в образе, а не в контейнере. Для этого есть команда `CMD`. Она запустит сервер, когда запустится контейнер, основанный на нашем готовом образе. Синтаксис похож на массив.
```docker
CMD ["python", "main.py"]
```

6. Также нужно открыть порт, на котором работает наше приложение:
```docker
EXPOSE 80
```

Докерфайл готов. 
```sh
# Билдим образ:
docker build путь_к_докерфайлу

# Если докерфайл в рабочей папке
docker build .

# Запускаем контейнер на основе нашего образа
docker run id_образа
docker run 0e0c44d8c8e17148fdc5e8124fe15f14931f79e7075af1f7cec28efb67ee0416

# Также нужно открыть порт при запуске контейнера
docker run -p порт_хоста:порт_внутри_контейнера id_образа
docker run -p 5000:80 0e0c44d8c8e17148fdc5e8124fe15f14931f79e7075af1f7cec28efb67ee0416

# Остановить контейнер (имя_образа можно посмотреть командой 'docker ps')
docker stop имя_образа

# Запустить контейнер опять
docker start имя_образа
```

Теперь наше приложение доступно по адресу `localhost:5000`.

## Кэш

Образы имеют многослойную архитектуру. Если изменить код или поменять инструкции в докерфайле, только изменённые инструкции будут выполнены. Всё, что не тронуто, будет взято из кэша.

Чтобы каждый раз не переустанавливать зависимости и т.д. можно их подтянуть заранее, перед копированием кода. Они будут кэшированы и больше не будут загружаться.

```docker
COPY requirements.txt /app

RUN pip install -r requirements.txt

COPY . /app
```

```
❯ docker build .
...
 => [1/5] FROM docker.io/library/python                         
 => [internal] load build context                               
 => => transferring context: 349B                               
 => CACHED [2/5] WORKDIR /app                                   
 => CACHED [3/5] COPY requirements.txt /app                     
 => CACHED [4/5] RUN pip install -r requirements.txt            
 => [5/5] COPY . /app                                           
...
```

## Привязанный и отвязанный режим

`docker run` запускает контейнер в привязанном режиме. То есть наш терминал блокируется и мы видим терминал внутри контейнера. Можно этого избежать, запустив контейнер в отвязанном режиме:
```
docker run -d id_образа
```

Запустить контейнер опять + привязаться к нему:
```
docker start -a контейнер
```

Можно привязаться к контейнеру с помощью `attach`:
```
docker attach контейнер
```

Посмотреть логи:
```
docker logs контейнер
```

## Управление образами и контейнерами

Вывести список образов:
```
docker images
```

Удалить образ:
```
docker rmi образ [образ образ...]
```

Удалить неиспользуемые образы:
```
docker image prune
```

Удалить все образы:
```
docker image prune -a
```

Удалить контейнер, когда он закончит работу:
```
docker run --rm контейнер
```

Вывести всю информацию об образе:
```
docker image inspect образ
```

## Наименование образов и контейнеров
Назвать контейнер myapp:
```
docker run --name myapp ...
```
```
❯ docker run -d -p 5000:80 --name myapp 1609a7b5123735f1f91d7e90830302d7167ed04bf039d788f166b80f4086369a
55f2dc5921aa93690df7f9b233d02c55dcd634d989921eeba7f8c7c1a8a810eb

❯ docker ps
CONTAINER ID   IMAGE          ...   NAMES
55f2dc5921aa   1609a7b51237   ...   myapp

❯ docker stop myapp
myapp
```

Образы именуются именуются тэгами
```
name:tag

python:3.9.4
node:latest
```
Задать имя и тэг:
```
docker build -t myapp:whatever

# Скопировать образ с новым именем
docker tag прошлый_образ новый_образ
```
```
❯ docker build -t myapp:whatever .
[+] Building 0.2s (10/10) FINISHED
...
 => => naming to docker.io/library/myapp:whatever

❯ docker images
REPOSITORY   TAG        IMAGE ID       CREATED        SIZE
myapp        whatever   1609a7b51237   11 hours ago   895MB
...
python       latest     49e3c70d884f   2 weeks ago    885MB

❯ docker run -d --name appcont myapp:whatever
2d2b3dcc928ddab059e50af4ba95a230df3d37f3e44bdeb8f19fb8ecf3df599a

❯ docker ps
CONTAINER ID   IMAGE            COMMAND            CREATED          STATUS          PORTS     NAMES
2d2b3dcc928d   myapp:whatever   "python main.py"   2 seconds ago    Up 1 second     80/tcp    appcont
```

## Копирование файлов

```
# Скопировать в/из контейнера
docker cp файл_или_папка контейнер:куда_копировать
docker cp контейнер:куда_копировать файл_или_папка
``` 

## Docker Hub

```
# Войти
docker login

# Выйти
docker logout

# Залить образ в хаб
docker push имя/репозиторий[:тэг]
```

## Volumes (разделы)

*Разделы* - хранилище, куда контейнеры могут сохранять данные. Папка в контейнере привязывается к хранилищу. Расположение на хосте управляются докером.

Посмотреть разделы:
```
docker volumes
```

### Анонимные разделы

Исчезают при удалении контейнера. Приложения в контейнере имеют ограниченный функционал в них. Названия генерируются автоматически.

```docker
VOLUME [ "папка/в/контейнере" ]
VOLUME [ "/app/media" ]
```
или
```
docker run -v папка/в/контейнере ...
```

### Именованные разделы

Данные сохраняются, даже если контейнер остановится. Имя и путь выбираются пользователем.

Добавить именнованный раздел при запуске:
```
docker run -v название_раздела:папка_в_контейнере ...
docker run -v feedback:/app/feedback ...
``` 

### Привязанные пути

Можно привязать папку/файл на хосте к папке/файлу в контейнере. Таким методом возможно редактирование из вне контейнера.

Привязать путь:
```
docker run -v абсолютный/путь/на/хосте:путь/в/контейнере ...
```
Такой длинный аргумент лучше закрывать в ковычки на случай спецсимволов.

Если указано несколько разделов, то более длинный путь имеет приоритет.

Read-only:
```
docker run -v абсолютный/путь/на/хосте:путь/в/контейнере:ro ...
```

# .dockerignore

Логика такая же, как и с гитом. Файлы указанные здесь не будут добавляться в образ.

# Аргументы и переменные окружения

## Аргументы

Доступны только внутри докерфайла. Можно изменять при билде образа с флагом `--build-args`. Нельзя использовать на команде `CMD`.

```docker
ARG DEFAULT_PORT=80

ENV PORT $DEFAULT_PORT

EXPOSE $PORT
```
```
docker build --build-arg DEFAULT_PORT=8000 .
```

## Переменные окружения

Доступны в докерфайле и в приложении. Устанавливаются через команду `ENV` в докефайле или через флаг `--env, -e` при `docker run`.

```docker
# PORT=80
ENV PORT 80

# Открыть порт, указанный в переменной PORT
EXPOSE $PORT
```

```
docker run -e PORT=8000 -e HOST=0.0.0.0
```

Можно использовать файл `.env`:
```
docker run --env-file ./.env
```

# Сеть

## Соединение с сетью
Приложения в контейнерах могут делать запросы в www. 

## Соединение с хостом
Но не могут делать запросы к приложениям в хосте. 

Чтобы подключится к сервису, запущенному на хосте, нужно заменить `localhost` на `host.docker.internal`.

```
http://host.docker.internal/...
mongodb://host.docker.internal/...
```

## Соединение с другими контейнерами
Чтобы соединиться с другими контейнерами нужно узнать их ip:
```
docker container inspect контейнер
# "IPAddress": "127.17.0.2"
```

## Сеть контейнеров
Контейнеры можно соединять в сети. Тогда они будут иметь доступ друг к другу автоматически.

```
http://имя_контейнера:порт/
```
Запустить контейнер в сети:
```
docker run --network сеть ...
```
Докер не создаёт сеть автоматически. Её нужно создавать вручную:
```
docker network create custom-network
```
Посмотреть все сети:
```
docker network ls
```

# Docker Compose

Вместе с сетями, портами, разделами и т.п. для запуска контейнеров и сборки образов приходиться составлять очень длинные команды. Также, образов и контейнеров может быть много на одной машине. Для того, чтобы всё это удобнее запускать можно использовать Docker Compose.

Конфиг для докер-компоуз описывается в `docker-compose.yaml`. 

Начинается с указания версии файла, т.к. в разных версиях могут быть разные фичи:
```yaml
# docker-compose.yaml
version: "3.8"
services:
    # контейнеры
```
Контейнеры по-умолчанию запускаются с флагами `--rm -d`. Поэтому их не нужно указывать.


```yaml
# docker-compose.yaml
version: "3.8"
services:
    version: "3.8"
services:
    имя_контейнера_1:
        image: 'название-образа'
        volumes:
            - data:/data/db
            - раздел 2

        # Есть 3 варианта указывания переменных окружения
        enviroment:
            DB_USERNAME: root
            DB_PASSWORD: secret
        enviroment:
            - DB_USERNAME=root
            - DB_PASSWORD=secret
        env_file:
            - ./env/mongo.env
            # - путь/ко/второму/файлу/env
        networks:
            # - my-network
            # - my-network-2
    имя_контейнера_2:
        # ...
```
Переменные окружения можно указывать в файлах, причем разнести по файлам для каждого контейнера.
Можно указывать сети, но композ автоматически подключает все контейнеры их файла в одну сеть.
Разделы нужно указывать в каждом контейнере. Именованые разделы нужно также указать отдельно:
```yaml
version: "3.8"
services:
    # ...
volumes:
    имя_раздел_1:
    имя_раздел_2:
```

Чтобы собрать образ, нужно указать пункт `build:`

Короткая форма:
```yaml
services:
    container_1:
        build: ./example_1    
        # ...
volumes:
    logs:
```

Развёрнутая форма:
```yaml
services:
    container_1:
        build:
            context: ./example_1
            dockerfile: Dockerfile-dev
            args:
                some-arg: 1
        # ...
```

`depends_on` позволяет запускать контейнер после того, как запустится другой: 
```yaml
services:
    container_1:
        build: ./example_1    
        ports:
            - '3000:80' # порт_внутри:порт_вне
            - '22:22' # можно указать несколько
        volumes:
            - logs:/app/logs
            - ./example_1:/app # Для привязанных путей можно 
                               # использовать относительные пути
        depends_on:
            - example_2
            # - ...
volumes:
    logs:
```

Флаг `-it` указывается таким образом:
```yaml
servies:
    serv_1:
        stdin_open: true
        tty: true
```

Композ даёт контейнерам имя: `имяпапки_имяконтейнера_номер`. Можно указать имя вручную: 
```yaml
services:
    container_1:
        container_name: 'mongo'
```

### Запуск композа:
```
docker-compose up -d

# Заставить образы пересобраться
docker-compose up --build

# Собрать образы, не запускать
docker-compose build
```

# Команды в контейнере

Параллельно с основной командой можно запускать другие команды:
```
docker exec -it контейнер команда
```

Заменить команду из докефайла:
```
docker run -it образ своя_команда
```
