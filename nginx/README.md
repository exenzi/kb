# Конфигурация Nginx

# Терминология

*Дериктива (Directive)* - заданная опция конфигурации. Состоит из имени и значения.
```nginx
server_name mydomain.com
```

*Контенкст (Context)* - область конфигурации. Директивы, заданные в ней, влияют на эту область. Они могут вкладываться друг в друга и наследовать значения от родителя. Самый главный контекст - сам кофигурационный файл и называется *Главный контекст (Main Context)*.
```nginx
http {
    # директивы, влияющие на http и server
    # ...

    server {
        # директивы, влияющие на server
        # ...
    }
}
```
# Создание виртуального хоста

*Виртуальный хост* может раздавать статические файлы. Допустим у нас есть html-страницы по пути `/sites/demo`. В нём будут находиться 3 файла:
```
index.html
style.css
thumb.png
```

Главный конфигурационный файл находится здесь: `/etc/nginx/nginx.conf`. Начнём строить его с нуля:
```nginx
events {} # контекст events удалять полностью нельзя, иначе файл будет невалидным

http {
    # ...
}
```

Каждый виртуальный хост означает новый контекст **server**. Виртуальный хост будет слушать порт **80** для http и **443** для https.
```nginx
events{}

http {
    server {
        listen 80; # всё директивы заканчиваются точкой с запятой

        server_name 16.231.154.7; 

        root /sites/demo;
    }
}
```
`listen порт` - какой порт слушать. Если не указывать порт, то nginx будет автоматически слушать порт 80. Но хорошей практикой считается указывать его очивидно. 

`server_name домен` - домен, субдомен или ip-адрес, для которого будет работать текущий контекст. В домене можно указывать звёздочку (__*__), которая означает _любое значение_. Например, `*.domain.com` будет совпадать с любым субдоменом.

`root путь` - путь, из которого nginx будет отдавать файлы при запросе. Если придёт запрос `/images/cat.png`, то nginx будет искать его в `[root]/images/cat.png`. В нашем случае `/sites/demo/images/cat.png`.

# Перезапуск nginx с помощью systemd

Проверить конфиг и, если он валидный, остановить сервер и запустить его заново:
```
systemctl reload nginx
```

Остановить сервер, потом проверить конфиг и, если он валидный, запустить сервер. Если конфиг окажется невалидный, то остановленный сервер откажется запускаться.
```
systemctl restart nginx
``` 

Проверить конфиг вручную:
```
nginx -t
```

# Mimetypes и `include`

Если запустим сервер, то увидим наш сайт. Но заметим, что стили не работают. Когда nginx отправлял файл style.css клиенту, то указал неверный Content-Type.

Проверить Content-Type:
```
curl -I http://ip-адрес/style.css

# Ответ:
# ...
Content-Type: text/plain
# ...
```

Для того, чтобы это исправить, мы должны сообщить nginx правильные mimetype для разных расширений файлов с помощью контекста `types {}`.
```nginx
# nginx.conf

http {
    types {
        text/html html;
        text/css css;

        server {
            # ...
        }
    }   
}
```

Но указывать вручную все эти типы необязательно, т.к. у nginx уже есть файл `mime.types`, содержащий много частоиспользуемых типов. 

Всё, что нам нужно, это подключить в конфиг с помощью `include`:
```nginx
# nginx.conf

http {
    types {
        include mime.types;

        server {
            # ...
        }
    }   
}
```

# Блоки локаций

Контексты `location {}` позволяют обрабатывать определённые пути по-особенному.
```nginx
server {
    location URI {
        # ...
    }
}
```

Например, будем возвращать строку клиенту, который будет переходить по адресу `/grret`:
```nginx
events{}

http {
    server {
        listen 80;
        server_name 16.231.154.7; 
        root /sites/demo;

        location /greet {
            return 200 "Hello from NGINX '/greet' location!";
        }
    }
}
```

`location URI` называется *совпадением префикса* (Prefix match). То есть, он сработает на все URI, которые начинаются с указанной строки. Например, `location /greet` также поймает `/greeting` и даже `/greeting/more`.

Если нужно точное совпадение (Exact match), то можно добавить знак равно `=`:
```nginx
location = /greet {
    # ...
}
```

Совпадение по регулярному выражению возможно с помощью тильды `~` и `~*`:
```nginx
# Совпадение с greet0, greet1 и т.д. (регистрозависимо)
location ~ /greet[0-9] {
    # ...
}

# Чтобы было регистроНЕзависимо, то используется тильда со звёздочкой (~*)
location ~* /greet[0-9] {
    # ...
}
```

Совпадение с регулярными выражениями имеет приоритет над префиксами. Если нужно это изменить, то нужно использовать морковку с тильдой `^~`:
```nginx
location ^~ /greet {
    # ...
}
```

## Приоритет: 
1. Точное `= uri`
2. Префикс с приоритетом `^~ uri`
3. Регулярные выражения `~ uri`
4. Префикс `uri`

# Переменные
Переменные делятся на кастомные и модульные.

## Кастомные переменные
```nginx
set $var 'something';
```
Переменным можно давать значения типа строк (string), целых чисел (integer) и правда/ложь (boolean).
```nginx
set $weekend 'No';
```

## Модульные переменные
```nginx
location /inspect {
    return 200 "$host\n$uri\n$args"
}
```
Запрос по адресу `http://34.54.23.12/inspect?name=max` вернёт:
```
34.54.23.12
/inspect
name=max
```
Можно получить доступ к определённому параметру. Nginx создаёт переменные в формате `$arg_параметр`.
```nginx
location /inspect {
    return 200 "Name: $arg_name"
}
```
вернёт:
```nginx
# http://34.54.23.12/inspect?name=max
Name: max
```

# Условия
Переменные часто используются вместе с условиями `if`. При этом важно знать, что использование условий внутри `location {}` категорически не приветствуется, т.к. может вести к непредсказуемым последствиям.

Ради примера приверим запрос на наличие API ключа:
```nginx
server {
    if ( $arg_apikey != 1234 ) {
        return 401 "Неверный ключ API";
    }

    location / {
        # ...
    }
}
```
Проверка выходного дня:
```nginx
server {
    set $weekend 'No';

    if ($date_local ~ 'Saturday|Sunday') {
        set $weekend 'Yes';
    }

    location /is_weekend {
        return 200 "$weekend";
    }
}
```
Проверка понедельника:
```nginx
server {
    set $mon 'No';

    if ($date_local ~ 'Monday') {
        set $mon 'Yes';
    }

    location /is_monday {
        return 200 "$mon";
    }
}
```
# Директивы `return` и `rewrite`

`return` возвращает ответ клиенту и имеет формат:
```nginx
return код 'ответ';

# Пример
return 200 'Hellow World`;
```
Но если код у нас один из 300-х, что означает redirect (перенаправление), то вместо ответа, `return` принимает путь:
```nginx
return 307 /some/path;

# Пример
# Зайдя по адресу /logo, клиента перебросит на адрес /thumb.png
location /logo {
    return 307 /thumb.png;
}
```

При перенаправлении адрес в браузере будет также меняться. Но мы можем делать не перенаправление (redirect), а перезапись (rewrite). В таком случае клиент будет получать иной ответ, но по изначальному адресу.
```nginx
server {
    # rewrite regex path;
    rewrite ^/user/\w+ /greet;

    location /greet {
        return 200 'Hello, User!';
    }
}
```
Когда nginx читает строку с `rewrite`, он переиницализирует её с самого начала уже с новым адресом.

Части ригулярных выражений можно захватывать с помощью *capture group*. Они будут доступны в виде `$1`, `$2` и т.д.
```nginx
rewrite ^/user/(\w+) /greet/$1;

location /greet {
        return 200 'Hello, User!';
    }

location = /greet/john { # Используем точное совпадение
        return 200 'Hello, John!';
    }
```

Перезаписи могут сработать несколько раз:
```nginx
rewrite ^/user/(\w+) /greet/$1;
rewrite /greet/john /thumb.png;

# Результат: 
# /user/john -> /greet/john -> /thumb.png
```

Можно приостановить перезаписи запроса, если добавить в конец `last`. Это будет последняя перезапись:
```nginx
rewrite ^/user/(\w+) /greet/$1 last;
rewrite /greet/john /thumb.png;
# Результат: 
# /user/john -> /greet/john
```

# Директива `try_files`
Пытается отдать файл, указанный первым. Если его не существует, то указанный втором. И т.д. Последний аргумент работает, как rewrite. Может использоваться в контексте `server` и `location`. Имеет преимущество над `location`.

```nginx
try_files file1 file2 final;
```

Часто используется с переменными, например, так можно сделать страницу с ошибкой 404:
```nginx
server {
    try_files $uri /cat.png /greet /friendly_404;

    location /friendly_404 {
        return 404 "Извините, такой файл не найдён.";
    }

    location /greet {
        return 200 "Hello User"'
    }
}
```
В данном примере, если запросим, например, `/nothing`, то `/greet` не сработает из-за того, что `try_files` ищет файлы только относительно `root`. Только последний аргумент срабатывает, как `rewrite`.

# Именованые локации

Локацию можно назвать, используя `@`. В `try_files` последним аргументом можно сразу вызвать именованную локацию, не затрачивая время на rewrite.

```nginx
server {
    try_files $uri /cat.png /greet @friendly_404;

    location @friendly_404 {
        return 404 "Извините, такой файл не найдён.";
    }

    location /greet {
        return 200 "Hello User"'
    }
}
```

# Логирование
Логи nginx делятся на 2 типа: Логи об ошибках (Error Log) и логи о всех запросах на сервер (Access Log). Логирование включено по-умолчанию.

Указать путь к логам можно с помощью аргемнтов при вызове nginx:
```
--error-log-path=/var/log/nginx/error.log --http-log-path=/var/log/nginx/access.log
```
 
В конфиге можно перенаправить логи в нужный файл для определённого контекста:
```nginx
location /secure {
    access_log /var/log/nginx/secure.access.log;
    return 200 "Welcome to secure area.";
}
```

Можно выключить логи в контексте. Это поможет сбавить нагрузку на сервер при большом трафике.
```nginx
location /secure {
    access_log off;
    # ...
}
```

# Типы директив
От типа директивы зависит то, как она будет наследоваться во внутринние контексты.

Есть 3 основных типа директив:
* Стандартная директива (Standard Directive)
* Массив (Array Directive)
* Действие (Action Directive)

## Директива - Массив
Может быть указана несколько раз. Новые директивы не перезаписывают прошлые, а дополняют их. Например, `access_log`. Наследуются дочерними контекстами. Но если указать её ещё раз в дочернем контексте, то в нём она перезапишется.

## Стандартная директива
Может быть указана только один раз. Новое объявление директивы перезапишет прошлое. Пример: `root`. Наследуется дочерними контекстами. Можно указать ещё раз в дочернем контексте, она перезапишется для этого контекста.

## Директива - Действие
Вызывает какое-то дейтсвие 1 раз. Например, `rewrite` и `redirect`. Не наследуется.

# Воркеры (Workers, Рабочие процессы) 
Когда запускается основной процесс nginx (master process), он пораждает рабочие процессы - воркеры, которые принимают и отвечают на клиентские запросы. По-умолчанию, nginx запускает только 1 воркер. Можно изменить количество воркеров в главном контексте:
```nginx
worker_processes 2;
```
В компьютере один процесс может работать только на одном ядре процессора. Соответственно, чтобы nginx мог использовать все ресурсы процессора, количество воркеров должно быть равно количеству ядер.
Узнать количество ядер:
```
nproc

# или

lscpu
# ...
CPU(s): 1
# ...
```

nginx может автоматически подобрать количество воркеров:
```nginx
worker_processes auto;
```

Мы можем указать, какое количество запросов каждый воркер может принять. 
```nginx
events {
    worker_connections 1024;
}
```
Но у нашего компьютера есть предел по количеству одновременно открытых файлов на ядро. Узнать можно так:
```
ulimit -n
```

**worker_processes** x **worker_connections** = максимальное количество соединений, наш сервер мржет обслуживать одновременно.

Можно указать, где будет находится файл PID (*process id*) нашего nginx:
```nginx
pid /var/run/new_nginx.pid;
```

# Буфферы и тайминги
Буфферизация - процесс записи данных в оперативную память. Когда приходит запрос, nginx записывает его в RAM. Если RAM не хватает, то часть данных записывается на диск. Когда нам нужно отдать файл, nginx записывает его в RAM и уже оттуда отдаёт клиенту.
Тайминги - время, которое отводится на определёные события. 

```nginx
http {
    client_body_buffer_size 10K;
    client_max_body_size 8m;

    client_header_buffer_size 1k;

    client_body_timeout 12;
    client_header_timeout 12;

    keepalive_timeout 15;

    send_timout 10;

    sendfile on;

    tcp_nopush on;
}
```
`client_body_buffer_size` - cколько памяти выделить для тела POST-запроса. Если слишком мало, то часть запроса будет писаться на диск.

`client_max_body_size` - максимальный размер POST-запроса. Если размер запроса превышает 8mb, то сервер вернёт код 413 "Запрос слишком большой".

`client_header_buffer_size` - размер выделяемой памяти для заголовков запроса клиента.

`client_body_timeout` и `client_header_timeout` - максимальное время получения тела/заголовков запроса клиента в буффер. По-умолчанию, равно 60 мс. Это время не всего запроса, а время между очередным чтением в буффер.

`keepalive_timeout` - время, которого nginx держит соединение открытым для клиента, если на пути ещё идут данные. Например, если клиент запрашивает много файлов, удержание соединения открытым может ускорить создание нового соединения. Но если сделать слишком долго, то повышается шанс првевысить максимальное количество одновременных соединений.

`send_timout` - максимальное время, чтобы клиент принял/получил ответ.

`sendfile on` - отправлять файл с диска клиента без записи в буффер.

`tcp_nopush on` - оптимизирует размеры пакетов, отправляемых клиенту.

# Headers & Срок годности

Хэдеры к ответам можно добавлять с помощью директивы `add_header`:
```nginx
add_header Header-Name "Hello World";
```

В хэдере можно указать срок годности файла. Браузер клиента закеширует файл до этого срока. Например, картинки на сайте меняются очень редко. Можно указать большой срок годности и браузер очень долго не будет обращаться за этой картинкой повторно. Файлы со стилями CSS вполне могут меняться чаще, поэтому им можно указать срок поменьше.
```nginx
location ~* \.(css|js|jpg|png) {
    access_log off;

    # Может быть закешировано как угодно
    add_header Cache-Control public;

    # Более старая версия Cache-Control
    add_header Pragma public;

    # Контент ответа может быть разным
    add_header Vary Accept-Encoding;

    # Спец. директива для сроков
    expires 1M; # 1 месяц
}
```

# Gzip
Когда браузер отправляет запрос, он может указать `Accept-Encoding: gzip`, что означает, что он может принимать сжатые файлы. Nginx может отправить сжатый ответ, что хорошо скажется на скорости.

```nginx
http {
    # Включаем сжатие
    gzip on;

    # Указываем уровень сжатия
    gzip_comp_level 3;

    # Какие файлы сжимать
    gzip_types text/css text/javascript;
}
```

Чем уровень сжатия выше, тем меньше будет размер файла, но на само сжатие тратится больше ресурсов сервера. Золотая середина - 3 или 4.