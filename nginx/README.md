# Конфигурация Nginx

## Терминология

*Дериктива (Directive)* - заданная опция конфигурации. Состоит из имени и значения.
```nginx
server_name mydomain.com
```

*Контенкст (Context)* - область конфигурации. Директивы, заданные в ней, влияют на эту область. Они могут вкладываться друг в друга и наследовать значения от родителя. Самый главный контекст - сам кофигурационный файл и называется *Главный контекст (Main Context)*.
```nginx
http {
    # директивы, влияющие на http и server
    # ...

    server {
        # директивы, влияющие на server
        # ...
    }
}
```
## Создание виртуального хоста

*Виртуальный хост* может раздавать статические файлы. Допустим у нас есть html-страницы по пути `/sites/demo`. В нём будут находиться 3 файла:
```
index.html
style.css
thumb.png
```

Главный конфигурационный файл находится здесь: `/etc/nginx/nginx.conf`. Начнём строить его с нуля:
```nginx
events {} # контекст events удалять полностью нельзя, иначе файл будет невалидным

http {
    # ...
}
```

Каждый виртуальный хост означает новый контекст **server**. Виртуальный хост будет слушать порт **80** для http и **443** для https.
```nginx
events{}

http {
    server {
        listen 80; # всё директивы заканчиваются точкой с запятой

        server_name 16.231.154.7; 

        root /sites/demo;
    }
}
```
`listen порт` - какой порт слушать. Если не указывать порт, то nginx будет автоматически слушать порт 80. Но хорошей практикой считается указывать его очивидно. 

`server_name домен` - домен, субдомен или ip-адрес, для которого будет работать текущий контекст. В домене можно указывать звёздочку (__*__), которая означает _любое значение_. Например, `*.domain.com` будет совпадать с любым субдоменом.

`root путь` - путь, из которого nginx будет отдавать файлы при запросе. Если придёт запрос `/images/cat.png`, то nginx будет искать его в `[root]/images/cat.png`. В нашем случае `/sites/demo/images/cat.png`.

## Перезапуск nginx с помощью systemd

Проверить конфиг и, если он валидный, остановить сервер и запустить его заново:
```
systemctl reload nginx
```

Остановить сервер, потом проверить конфиг и, если он валидный, запустить сервер. Если конфиг окажется невалидный, то остановленный сервер откажется запускаться.
```
systemctl restart nginx
``` 

Проверить конфиг вручную:
```
nginx -t
```

## Mimetypes и `include`

Если запустим сервер, то увидим наш сайт. Но заметим, что стили не работают. Когда nginx отправлял файл style.css клиенту, то указал неверный Content-Type.

Проверить Content-Type:
```
curl -I http://ip-адрес/style.css

# Ответ:
# ...
Content-Type: text/plain
# ...
```

Для того, чтобы это исправить, мы должны сообщить nginx правильные mimetype для разных расширений файлов с помощью контекста `types {}`.
```nginx
# nginx.conf

http {
    types {
        text/html html;
        text/css css;

        server {
            # ...
        }
    }   
}
```

Но указывать вручную все эти типы необязательно, т.к. у nginx уже есть файл `mime.types`, содержащий много частоиспользуемых типов. 

Всё, что нам нужно, это подключить в конфиг с помощью директивы `include`:
```nginx
# nginx.conf

http {
    types {
        include mime.types;

        server {
            # ...
        }
    }   
}
```

## Блоки локаций

Контексты `location {}` позволяют обрабатывать определённые пути по-особенному.
```nginx
server {
    location URI {
        # ...
    }
}
```

Например, будем возвращать строку клиенту, который будет переходить по адресу `/grret`:
```nginx
events{}

http {
    server {
        listen 80;
        server_name 16.231.154.7; 
        root /sites/demo;

        location /greet {
            return 200 "Hello from NGINX '/greet' location!";
        }
    }
}
```

`location URI` называется *совпадением префикса* (Prefix match). То есть, он сработает на все URI, которые начинаются с указанной строки. Например, `location /greet` также поймает `/greeting` и даже `/greeting/more`.

Если нужно точное совпадение (Exact match), то можно добавить знак равно `=`:
```nginx
location = /greet {
    # ...
}
```

Совпадение по регулярному выражению возможно с помощью тильды `~` и `~*`:
```nginx
# Совпадение с greet0, greet1 и т.д. (регистрозависимо)
location ~ /greet[0-9] {
    # ...
}

# Чтобы было регистроНЕзависимо, то используется тильда со звёздочкой (~*)
location ~* /greet[0-9] {
    # ...
}
```

Совпадение с регулярными выражениями имеет приоритет над префиксами. Если нужно это изменить, то нужно использовать морковку с тильдой `^~`:
```nginx
location ^~ /greet {
    # ...
}
```

### Приоритет: 
1. Точное `= uri`
2. Префикс с приоритетом `^~ uri`
3. Регулярные выражения `~ uri`
4. Префикс `uri`

## Переменные
Переменные делятся на кастомные и модульные.

### Кастомные переменные
```nginx
set $var 'something';
```
Переменным можно давать значения типа строк (string), целых чисел (integer) и правда/ложь (boolean).
```nginx
set $weekend 'No';
```

### Модульные переменные
```nginx
location /inspect {
    return 200 "$host\n$uri\n$args"
}
```
Запрос по адресу `http://34.54.23.12/inspect?name=max` вернёт:
```
34.54.23.12
/inspect
name=max
```
Можно получить доступ к определённому параметру. Nginx создаёт переменные в формате `$arg_параметр`.
```nginx
location /inspect {
    return 200 "Name: $arg_name"
}
```
вернёт:
```nginx
# http://34.54.23.12/inspect?name=max
Name: max
```

## Условия
Переменные часто используются вместе с условиями `if`. При этом важно знать, что использование условий внутри `location {}` категорически не приветствуется, т.к. может вести к непредсказуемым последствиям.

Ради примера приверим запрос на наличие API ключа:
```nginx
server {
    if ( $arg_apikey != 1234 ) {
        return 401 "Неверный ключ API";
    }

    location / {
        # ...
    }
}
```
Проверка выходного дня:
```nginx
server {
    set $weekend 'No';

    if ($date_local ~ 'Saturday|Sunday') {
        set $weekend 'Yes';
    }

    location /is_weekend {
        return 200 "$weekend";
    }
}
```
Проверка понедельника:
```nginx
server {
    set $mon 'No';

    if ($date_local ~ 'Monday') {
        set $mon 'Yes';
    }

    location /is_monday {
        return 200 "$mon";
    }
}
```
## Директивы `return` и `rewrite`

`return` возвращает ответ клиенту и имеет формат:
```nginx
return код 'ответ';

# Пример
return 200 'Hellow World`;
```
Но если код у нас один из 300-х, что означает redirect (перенаправление), то вместо ответа, `return` принимает путь:
```nginx
return 307 /some/path;

# Пример
# Зайдя по адресу /logo, клиента перебросит на адрес /thumb.png
location /logo {
    return 307 /thumb.png;
}
```

При перенаправлении адрес в браузере будет также меняться. Но мы можем делать не перенаправление (redirect), а перезапись (rewrite). В таком случае клиент будет получать иной ответ, но по изначальному адресу.
```nginx
server {
    # rewrite regex path;
    rewrite ^/user/\w+ /greet;

    location /greet {
        return 200 'Hello, User!';
    }
}
```
Когда nginx читает строку с `rewrite`, он переиницализирует её с самого начала уже с новым адресом.

Части ригулярных выражений можно захватывать с помощью *capture group*. Они будут доступны в виде `$1`, `$2` и т.д.
```nginx
rewrite ^/user/(\w+) /greet/$1;

location /greet {
        return 200 'Hello, User!';
    }

location = /greet/john { # Используем точное совпадение
        return 200 'Hello, John!';
    }
```

Перезаписи могут сработать несколько раз:
```nginx
rewrite ^/user/(\w+) /greet/$1;
rewrite /greet/john /thumb.png;

# Результат: 
# /user/john -> /greet/john -> /thumb.png
```

Можно приостановить перезаписи запроса, если добавить в конец `last`. Это будет последняя перезапись:
```nginx
rewrite ^/user/(\w+) /greet/$1 last;
rewrite /greet/john /thumb.png;
# Результат: 
# /user/john -> /greet/john
```

## Директива `try_files`
Пытается отдать файл, указанный первым. Если его не существует, то указанный втором. И т.д. Последний аргумент работает, как rewrite. Может использоваться в контексте `server` и `location`. Имеет преимущество над `location`.

```nginx
try_files file1 file2 final;
```

Часто используется с переменными, например, так можно сделать страницу с ошибкой 404:
```nginx
server {
    try_files $uri /cat.png /greet /friendly_404;

    location /friendly_404 {
        return 404 "Извините, такой файл не найдён.";
    }

    location /greet {
        return 200 "Hello User"'
    }
}
```
В данном примере, если запросим, например, `/nothing`, то `/greet` не сработает из-за того, что `try_files` ищет файлы только относительно `root`. Только последний аргумент срабатывает, как `rewrite`.

## Именованые локации

Локацию можно назвать, используя `@`. В `try_files` последним аргументом можно сразу вызвать именованную локацию, не затрачивая время на rewrite.

```nginx
server {
    try_files $uri /cat.png /greet @friendly_404;

    location @friendly_404 {
        return 404 "Извините, такой файл не найдён.";
    }

    location /greet {
        return 200 "Hello User"'
    }
}
```